--1.remove only middle * from below : ****Hello****World****
SELECT REGEXP_REPLACE('****Hello****World****', '(\*\*\*\*)Hello\1World\1', '\1HelloWorld\1') AS result
FROM dual;

--2. Print Next sunday 
SELECT NEXT_DAY(SYSDATE, 'SUNDAY') AS next_sunday FROM dual;

--3.Print first day of month
SELECT TRUNC(SYSDATE, 'MONTH') AS first_day_of_month
FROM dual;

--4. Print date , month, year in different columns from sysdate. 
SELECT 
    EXTRACT(DAY FROM SYSDATE) AS day,
    EXTRACT(MONTH FROM SYSDATE) AS month,
    EXTRACT(YEAR FROM SYSDATE) AS year
FROM dual;

--5.Generate numbers from 1 to 10 (pending)
SELECT LEVEL FROM DUAL CONNECT BY <= 10;

Begin
  For i in 1..10
  Loop
    dbms_output.put_line(i);
  End loop;
End;
/

--6. Generate next 5 days and print the dates. 
SELECT SYSDATE + LEVEL - 1 AS Next_Day
FROM dual
CONNECT BY LEVEL <= 5;

SELECT SYSDATE + LEVEL AS Next_Day
FROM dual
CONNECT BY LEVEL <= 5;

--7. Print Odd number of rows from a table. 
SELECT *
FROM (
    select e.*, ROWNUM as rn
    from (SELECT * FROM EMPLOYEES ORDER BY employee_id)e
)
WHERE MOD(rn,2)=0;

SELECT *
FROM (
    SELECT EMPLOYEES.*, ROW_NUMBER() OVER (ORDER BY employee_id) AS rn
    FROM EMPLOYEES
) 
WHERE MOD(rn, 2) = 0;

--8. Print even number of rows from a Table.
SELECT *
FROM (
    SELECT EMPLOYEES.*, ROW_NUMBER() OVER (ORDER BY employee_id) AS rn
    FROM EMPLOYEES
) 
WHERE MOD(rn, 2) = 1;

--9.  print first 3 rows from a table
SELECT * FROM EMPLOYEES where ROWNUM <= 3;

--10. print last 3 rows from table 
SELECT * 
FROM (
    SELECT * 
    FROM EMPLOYEES
    ORDER BY EMPLOYEE_ID DESC
) 
WHERE ROWNUM <= 3 ORDER BY EMPLOYEE_ID;

--13.  print department wise employees count
SELECT d.DEPARTMENT_NAME, COUNT(e.EMPLOYEE_ID) AS employee_count FROM DEPARTMENTS d
LEFT JOIN EMPLOYEES e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID 
GROUP BY d.DEPARTMENT_NAME ORDER BY employee_count DESC;

SELECT DISTINCT
    d.DEPARTMENT_NAME,
    COUNT(e.EMPLOYEE_ID) OVER (PARTITION BY d.DEPARTMENT_ID) AS EMPLOYEE_COUNT
FROM DEPARTMENTS d
LEFT JOIN EMPLOYEES e ON d.DEPARTMENT_ID = e.DEPARTMENT_ID
ORDER BY EMPLOYEE_COUNT DESC;

--14. print 3 rd maximum salary  with using analytical function and without using analytical function 
SELECT MIN(SALARY)AS third_max_salary
FROM (
     SELECT DISTINCT SALARY FROM EMPLOYEES ORDER BY SALARY DESC
     ) WHERE ROWNUM <= 3;
     
--14.2.ALTERNATIVE METHOD USING ANALYTICAL FUNCTION
SELECT SALARY
FROM (
     SELECT SALARY, DENSE_RANK() OVER (ORDER BY SALARY DESC) AS salary_rank
     FROM EMPLOYEES
)WHERE salary_rank = 3;

--15.  print 3 rd minimum salary
SELECT MIN(SALARY) AS third_minimum_salary
FROM (
    SELECT DISTINCT SALARY FROM EMPLOYEES ORDER BY SALARY ASC
) 
WHERE ROWNUM <= 3;

--16.print maximum salary from each department.
SELECT DEPARTMENT_ID, MAX(SALARY) FROM EMPLOYEES GROUP BY DEPARTMENT_ID;

SELECT e.DEPARTMENT_ID, d.DEPARTMENT_NAME, MAX(e.SALARY) AS maximum_salary FROM EMPLOYEES e
JOIN DEPARTMENTS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID 
GROUP BY d.DEPARTMENT_NAME, e.DEPARTMENT_ID ORDER BY maximum_salary DESC;

--17.print middle record from the table
--17.1. 
WITH OrderedSalaries AS (
    SELECT 
        SALARY,
        ROW_NUMBER() OVER (ORDER BY SALARY) AS rn,
        COUNT(*) OVER () AS total_count
    FROM 
        EMPLOYEES
)
SELECT 
    SALARY
FROM 
    OrderedSalaries
WHERE 
    rn = CEIL(total_count / 2);

--17.2.   
WITH NumberedRows AS (
    SELECT 
        SALARY,
        ROW_NUMBER() OVER (ORDER BY SALARY) AS rn,
        COUNT(*) OVER () AS total_count
    FROM 
        EMPLOYEES
)
SELECT 
    SALARY
FROM 
    NumberedRows
WHERE 
    rn = FLOOR((total_count + 1) / 2);

--18.  print n th record of the table.
SELECT * 
FROM (SELECT * FROM EMPLOYEES ORDER BY EMPLOYEE_ID DESC) 
WHERE ROWNUM = 1;

SELECT *
FROM (
     SELECT e.*, ROW_NUMBER() OVER(ORDER BY EMPLOYEE_ID DESC) AS rn
     FROM EMPLOYEES e
)
WHERE rn = 1;

--19.print duplicate records from the table (with and without using analytical functions) 
 SELECT DISTINCT EMPLOYEE_ID FROM EMPLOYEES;
 --19.1. WITHOUT USING ANALYTICAL FUNCTION
 SELECT FIRST_NAME, LAST_NAME, COUNT(*) AS duplicate_count
 FROM EMPLOYEES
 GROUP BY FIRST_NAME, LAST_NAME
 HAVING COUNT(*) > 1;

--19.2. WITH ANALYTICAL FUNCTION
SELECT * 
FROM (
     SELECT e.*, ROW_NUMBER() OVER (PARTITION BY FIRST_NAME, LAST_NAME ORDER BY EMPLOYEE_ID) AS rn
     FROM EMPLOYEES e
     )
WHERE rn > 1;

--20. delete duplicate records from the table
DELETE FROM EMPLOYEES
WHERE employee_id IN(
        SELECT EMPLOYEE_ID FROM (
              SELECT EMPLOYEE_ID, ROW_NUMBER() OVER(PARTITION BY FIRST_NAME, LAST_NAME ORDER BY employee_id) AS rn
              FROM EMPLOYEES 
              ) 
        WHERE rn>1
); 

--21. scenario.
CREATE TABLE employees_a(
      emp_id NUMBER PRIMARY KEY,
      emp_name VARCHAR2(100)
      );
      
INSERT INTO employees_a(emp_id, emp_name) VALUES (1,'X');
INSERT INTO employees_a(emp_id, emp_name) VALUES (2,'Y');
INSERT INTO employees_a(emp_id, emp_name) VALUES (3,'Z');


      
CREATE TABLE emp_detail_a(
      emp_id NUMBER,
      adddress VARCHAR2(100)
      );


INSERT INTO emp_detail_a(emp_id, adddress) VALUES (1, 'addr1');
INSERT INTO emp_detail_a(emp_id, adddress) VALUES (2, 'addr2');
INSERT INTO emp_detail_a(emp_id, adddress) VALUES (1, 'addr3');
INSERT INTO emp_detail_a(emp_id, adddress) VALUES (2, 'addr4');
INSERT INTO emp_detail_a(emp_id, adddress) VALUES (3, 'addr5');

--22. print Empid , empname From above table who are all having multiple addresses 
SELECT e.emp_id, e.emp_name 
FROM employees_a e
JOIN emp_detail_a d ON e.emp_id = d.emp_id
GROUP BY e.emp_id, e.emp_name 
HAVING COUNT(d.adddress) > 1;

--23. print Empid , empname From above table who are all having single address. 
SELECT e.emp_id, e.emp_name 
FROM employees_a e
JOIN emp_detail_a d ON e.emp_id = d.emp_id
GROUP BY e.emp_id, e.emp_name 
HAVING COUNT(d.adddress) = 1;

--24. Table t1 having records from 1 to 10, But some of records are missing from T1  Print missing records from t1.
--25.Print first_name, department_name , city From  Employees , departments, locations Tables 
SELECT e.FIRST_NAME, d.DEPARTMENT_NAME, l.CITY FROM EMPLOYEES e
JOIN DEPARTMENTS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID
JOIN LOCATIONS l ON l.LOCATION_ID = d.LOCATION_ID;


SELECT column_name 
FROM all_tab_columns 
WHERE table_name = 'LOCATIONS';

--26.Print Employee details Who are all getting salary more than avg of salary from their own department
SELECT e.DEPARTMENT_ID, e.EMPLOYEE_ID, e.FIRST_NAME, e.LAST_NAME
FROM EMPLOYEES e
WHERE SALARY > (
      SELECT AVG(e1.SALARY) FROM EMPLOYEES e1
      WHERE e1.DEPARTMENT_ID = e.DEPARTMENT_ID);

--27.  Print inner join, left outer, right outer , full outer , and cross join output of these tables
CREATE TABLE t1(
       a NUMBER
       );
       
CREATE TABLE t2(
       b NUMBER
       );
       
INSERT INTO t1 (a) VALUES (1);
INSERT INTO t1 (a) VALUES (2);
INSERT INTO t1 (a) VALUES (3);
INSERT INTO t1 (a) VALUES (4);
INSERT INTO t1 (a) VALUES (5);
INSERT INTO t2 (b) VALUES (3);
INSERT INTO t2 (b) VALUES (4);
INSERT INTO t2 (b) VALUES (5);
INSERT INTO t2 (b) VALUES (6);

--inner join
SELECT t1.a, t2.b FROM t1
INNER JOIN t2 ON t1.a = t2.b;
--left join
SELECT t1.a, t2.b FROM t1
LEFT JOIN t2 ON t1.a = t2.b;
--Right Join
SELECT t1.a, t2.b FROM t1
RIGHT JOIN t2 ON t1.a = t2.b;
--full outer join
SELECT t1.a, t2.b FROM t1
FULL OUTER JOIN t2 ON t1.a = t2.b;
--CROSS JOIN
SELECT t1.a, t2.b FROM t1
CROSS JOIN t2;

--28.  I have to insert records to t2 from t1 , But That insert statement should not insert duplicates. 
INSERT INTO t2 (b)
SELECT a
FROM t1
WHERE NOT EXISTS (
    SELECT 1
    FROM t2
    WHERE t2.b = t1.a
);
select * from t2;


